<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Scaling Node.js App | EzCook</title><meta name="description" content="Strategies of ScalabilityThe workload is the most popular reason we scale our applications, but it’s not the only reason. We also scale our applications to increase their availability and tolerance to"><meta name="keywords" content="Node.js"><meta name="author" content="Chen Yu"><meta name="copyright" content="Chen Yu"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="https://ezcook.de/2017/08/22/Scaling-Node-js-App/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin="crossorigin"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Scaling Node.js App"><meta property="og:url" content="https://ezcook.de/2017/08/22/Scaling-Node-js-App/"><meta property="og:site_name" content="EzCook"><meta property="og:description" content="Strategies of ScalabilityThe workload is the most popular reason we scale our applications, but it’s not the only reason. We also scale our applications to increase their availability and tolerance to"><meta property="og:image" content="https://ezcook.de/img/default_cover_1.jpg"><meta property="article:published_time" content="2017-08-22T03:42:52.000Z"><meta property="article:modified_time" content="2020-08-30T12:51:38.860Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-136207372-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-136207372-1');
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: {"appId":"KU7XP6WJWL","apiKey":"6806ddc27f224d4ebc2fe49dc770371c","indexName":"Blog","hits":{"per_page":6},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: false,
  copyright: {"limitCount":50,"languages":{"author":"Author: Chen Yu","link":"Link: ","source":"Source: EzCook","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-08-30 20:51:38'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.1.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/gotterdammerung.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">311</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">76</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-address-card"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/portfolio/"><i class="fa-fw fas fa-code"></i><span> Portfolio</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Strategies-of-Scalability"><span class="toc-number">1.</span> <span class="toc-text">Strategies of Scalability</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cloning"><span class="toc-number">1.1.</span> <span class="toc-text">Cloning</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Decomposing"><span class="toc-number">1.2.</span> <span class="toc-text">Decomposing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Splitting"><span class="toc-number">1.3.</span> <span class="toc-text">Splitting</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-Cluster-Module"><span class="toc-number">2.</span> <span class="toc-text">The Cluster Module</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Load-Balancing-an-HTTP-Server"><span class="toc-number">3.</span> <span class="toc-text">Load-Balancing an HTTP Server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Broadcasting-Messages-to-All-Workers"><span class="toc-number">4.</span> <span class="toc-text">Broadcasting Messages to All Workers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Increasing-Server-Availability"><span class="toc-number">5.</span> <span class="toc-text">Increasing Server Availability</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Zero-downtime-Restarts"><span class="toc-number">6.</span> <span class="toc-text">Zero-downtime Restarts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shared-State-and-Sticky-Load-Balancing"><span class="toc-number">7.</span> <span class="toc-text">Shared State and Sticky Load Balancing</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(/img/default_cover_1.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">EzCook</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-address-card"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/portfolio/"><i class="fa-fw fas fa-code"></i><span> Portfolio</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Scaling Node.js App</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2017-08-22T03:42:52.000Z" title="Created 2017-08-22 11:42:52">2017-08-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2020-08-30T12:51:38.860Z" title="Updated 2020-08-30 20:51:38">2020-08-30</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">Comments:</span><span class="disqus-comment-count comment-count"><a href="https://ezcook.de/2017/08/22/Scaling-Node-js-App/#disqus_thread"></a></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h3 id="Strategies-of-Scalability"><a href="#Strategies-of-Scalability" class="headerlink" title="Strategies of Scalability"></a>Strategies of Scalability</h3><p>The workload is the most popular reason we scale our applications, but it’s not the only reason. We also scale our applications to increase their availability and tolerance to failure.</p>
<h4 id="Cloning"><a href="#Cloning" class="headerlink" title="Cloning"></a>Cloning</h4><p>The easiest thing to do to scale a big application is to clone it mulitple times and have each cloned instance handle part of the workload(with a load balancer). This does not cost a lot in term of development time and it’s highly effective. This strategy is the minimum you should do and Node.js has the built-in module, <code>cluster</code>, to make is easier for you to implement the cloning strategy on a single server.</p>
<h4 id="Decomposing"><a href="#Decomposing" class="headerlink" title="Decomposing"></a>Decomposing</h4><p>We can also scale an application by decomposiing it based on functionalities and services. This means having mulitple, different applications with different code bases and sometimes with their own dedicated databases and User Interfaces.</p>
<p>This strategy is commonly associated with the term <strong>Microservice</strong>, where micro indicates that those services should be small as possible, but in reality, the size of the service is not what’s important but rather the enforement of loose coupling and high cohesion between services.</p>
<h4 id="Splitting"><a href="#Splitting" class="headerlink" title="Splitting"></a>Splitting</h4><p>We can also split the application into multiple instances where each instance is responsible for only a part of the application’s data. This strategy is often named <strong>horizontal partitioning</strong>, or <strong>sharding</strong>, in database. Data partitioning requires a lookup step before each operation to determine which instance of the application to use.</p>
<p>Successfully scaling a big application should eventually implement all three strategies.</p>
<h3 id="The-Cluster-Module"><a href="#The-Cluster-Module" class="headerlink" title="The Cluster Module"></a>The Cluster Module</h3><p>The cluster module can be used to enable load balancing over an environement’s multiple CPU cores. It’s based on the child process module <code>fork</code> method and it basically allows us to fork the main application process as many times as we have CPU cores. It will then take over and load balance all requests to the main process across all forked processs.</p>
<p>The cluster module is Node’s helper for us to implement the cloning scalability strategy, but only on one machine. When you have a big machine with a lot resources or when it’s easier and cheaper to add more resources to one machine ratherthan adding new machine, the cluster module is a greate option for a really quick implementation of the cloning strategy.</p>
<p>Even small machines usually have multiple cores and even if you’re not worried about the load on your Node server, you should enable the cluster module anyway to increase your server availability and fault-tolerance.</p>
<p>It’s a simple step and when using a process manager like PM2, for example, it becomes as simple as just providing an argument to the launch command.</p>
<p>The structure of what the cluster module does is simple. We create a <em>master process</em> and that master process <em>forks</em> a number of <em>worker processes</em> and manage them. Each worker process represents an instance of the application that we want to scale. All incoming requests are handled by the master process, which is the one that decides which worker process should handle the incoming request.</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*C7ICI8d7aAna_zTZvZ64MA.png"></p>
<p>The master process’s job is easy because it actually just uses a <em>round-robin</em> algorithm to pick a worker process. This is enabled by default on all platform except windows and it can be globally modified to let the load-balancing be handled by the operation system self.</p>
<p>The round-robin algorithm distributes the load evenly across all available processes on a rotational basis. The first request is forwarded to the first worker process, the second to the next worker process in the list, and so on. When the end of the list is reached, the algorithm starts again from the beginning.</p>
<h3 id="Load-Balancing-an-HTTP-Server"><a href="#Load-Balancing-an-HTTP-Server" class="headerlink" title="Load-Balancing an HTTP Server"></a>Load-Balancing an HTTP Server</h3><p>Let’s clone and load balance a simple HTTP server using the cluster module.</p>
<p>Here’s the simple Node’s hello-world example server slightly modified to simulate some CPU work before responding:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> pid = process.pid</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1e7</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// simulate CPU work</span></span><br><span class="line">  &#125;</span><br><span class="line">  res.end(<span class="string">`Handled by process <span class="subst">$&#123;pid&#125;</span>`</span>)</span><br><span class="line">&#125;).listen(<span class="number">8080</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Started process <span class="subst">$&#123;pid&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Before we create a cluster to clone this server into multiple workers, let’s do a simple benchmark of how many requests this server can handle per second. We can use <strong>Apache benchmarking tool</strong> for that.</p>
<p>After running the simple <code>server.js</code> code above, run this <code>ab</code> command:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -c200 http://localhost:8080/</span><br></pre></td></tr></table></figure>

<p>This command will test-load the server with 200 concurrent connections for 10 seconds.</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*w8VmzV81atlTzHn7pDXu1g.png"></p>
<p>The single node server was able to handle about 51 requests per seconds.</p>
<p>Now that we have a reference benchmark, we can scale the application with the cloning strategy using the cluster module.</p>
<p>On the same level as the <code>server.js</code> file above, we can create a new file(<code>cluster.js</code>) <strong>for the master process</strong> with this content:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cluster.js</span></span><br><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">&#x27;cluster&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">  <span class="keyword">const</span> cpu = os.cpus().length</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Forking for <span class="subst">$&#123;cpu&#125;</span> CPUS`</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cpus; i++) &#123;</span><br><span class="line">    cluster.fork()</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">require</span>(./server)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In <code>cluster.js</code>, we first required both the <code>cluster</code> module and the <code>os</code> module, we use the <code>os</code> module to read the number of CPUS cores we can work with using <code>os.cpus()</code>.</p>
<p>The <code>cluster</code> module gives us the handy Boolean flag <code>isMaster</code> to determine if this <code>cluster.js</code> file is being loaded as a master process or not. The first time we execute this file, we will be executing the master process and that <code>isMaster</code> flag will be set to true. In this case, we can instruct the master process to fork our server as many times as we have CPU cores.</p>
<p>Now we just read the number of CPUs we have using the <code>os</code> module, then with a for loop over that number, we call the <code>cluster.fork</code> method. The for loop will simple create as many workers as the number of CPUs in the system to take advantage of all the available processing power.</p>
<p>When the <code>cluster.fork</code> line is executed from the master process, the current file, <code>cluster.js</code>, is run again, but this time in <em>worker mode</em> with the <code>isMaster</code> flag set to false.</p>
<p><em>There is actually another flag set to true in this case if you need to use it, which is the <code>isWorker</code></em> flag.</p>
<p>When the application runs as a worker, it can start doing the actual work. This is where we need to define our server logic, which, for this example, we can do by requiring the <code>server.js</code> file that we already have.</p>
<p>That’s basically it. That’s how easy it is to take advantage of all the processing power in a machine. To test the cluster, run the <code>cluster.js</code> file.</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*c0S-W4GYgCGB_maJ94ZLPw.png"></p>
<p>It’s important to understand that these are completely different Node.js processes. Each worker process here will have its own event loop and memory space.</p>
<p>When we now hit the web server multiple times, the requests will start to get handled by different worker processes with different process ids. The worker will not be exactly rotated in sequence because the cluster module performs some optimizations when picking the next worker, but the load will be somehow distributed among the different worker process.</p>
<p>We can use the same <code>ab</code> command above to load-test this cluster of processes:</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*5_EogHG-Egf2uAMOj9PmCA.png"></p>
<p>Now the cluster can handle 181 requests per seconds.</p>
<h3 id="Broadcasting-Messages-to-All-Workers"><a href="#Broadcasting-Messages-to-All-Workers" class="headerlink" title="Broadcasting Messages to All Workers"></a>Broadcasting Messages to All Workers</h3><p>Communicating between the master process and the workers is simple because under the hood the cluster module is just using the <code>child_process.fork</code> API, which means we also have communication channels available between the master process and each workers.</p>
<p>Based on the <code>server.js</code>/<code>cluster.js</code> example above, we can access the list of worker objects using <code>cluster.workers</code>, which is an object that holds a reference to all workers and can be used to read information about these workers. Since we have communication channels between master process and all workers, to broadcast a message to all them we just need a simple loop over all the workers:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values(cluster.workers).forEach(<span class="function"><span class="params">worker</span> =&gt;</span> &#123;</span><br><span class="line">  worker.send(<span class="string">`Hello Worker <span class="subst">$&#123;worker.pid&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>We simple used <code>Object.values</code> to get an array of all workers from the <code>cluster.workers</code> object. Then for each worker we can use the <code>send</code> function to send over any value that we want.</p>
<p>In a worker file, <code>server.js</code> in our example, to read a message received from this master process, we can register a handler for the <code>message</code> event on the global <code>process</code> object:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Message from master: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn-images-1.medium.com/max/1000/1*6XfoWiNKTCiDjqar7L5_xw.png"></p>
<p>Every worker received a message from the master process. <em>Note how the workers did not start in order</em>.</p>
<p>Let’s make this communication example a little bit more practical. Let’s say we want our server to reply with the number of users we have created in our database. We will create a mock function that returns the number of users we have in the database and just have it square its value every time it’s called:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// **** Mock DB Call</span></span><br><span class="line"><span class="keyword">const</span> numberOfUsersInDB = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.count = <span class="built_in">this</span>.count || <span class="number">5</span></span><br><span class="line">  <span class="built_in">this</span>.count = <span class="built_in">this</span>.count * <span class="built_in">this</span>.count</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Every time <code>numberOfUsersInDB</code> is called, we’ll assume that a database connection has been made.</p>
<p>In the master process mode, we can use the same loop to broadcast the users count value to all workers:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Right After the fork loop within the isMaster=true block</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> updateWorkers = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> usersCount = numberOfUsersInDB()</span><br><span class="line">  <span class="built_in">Object</span>.values(cluster.workers).forEach(<span class="function"><span class="params">worker</span> =&gt;</span> &#123;</span><br><span class="line">    worker.send(&#123;</span><br><span class="line">      usersCount,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">updateWorkers()</span><br><span class="line"><span class="built_in">setInterval</span>(updateWorkers, <span class="number">10000</span>)</span><br></pre></td></tr></table></figure>

<p>Here we’re invoking <code>updateWorkers</code> for the first time and then invoking it every 10 seconds using a <code>setInterval</code>. This way, every 10 seconds, all workers will receive the new user count value over the process communication channel and only one database connection will be made.</p>
<p>In the server code, we can use the <code>userCount</code> value using the same <code>message</code> event handler. We can simply cache that value with a module global variable and use it anywhere we want.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> pid = process.pid</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> usersCount</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1e7</span>; i++);</span><br><span class="line">  res.write(<span class="string">`Handled by process: <span class="subst">$&#123;pid&#125;</span>`</span>)</span><br><span class="line">  res.end(<span class="string">`Users: &#123;usersCount&#125;`</span>)</span><br><span class="line">&#125;).listen(<span class="number">8080</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Start process <span class="subst">$&#123;pid&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">  usersCount = msg.usersCount</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>The above code makes the worker web server respond with the cached <code>usersCount</code> value. If you test the cluster code now, during the first 10 seconds you’ll get ‘25’ as the users count from all workers(and only one DB request would be made). Then after another 10 seconds, all workers would start reporting the new user count: 625(and only one DB request would be made).</p>
<p>This is all possible thanks to the communication channels between the master process and all workers.</p>
<h3 id="Increasing-Server-Availability"><a href="#Increasing-Server-Availability" class="headerlink" title="Increasing Server Availability"></a>Increasing Server Availability</h3><p>One of the problems in running a single instance of a Node application is that when that instance crashes, it has to be restarted. This means some downtime between these two actions, even if the process was automated as it should.</p>
<p>This also applies to the case when the server has to be restarted to deploy new code. With one instance, there will be downtime which affects the availability of the system.</p>
<p>When we have multiple instances, the availability of the system can be easily increased with just a few extra lines of code.</p>
<p>To simulate a random crash in the server process, we can simply do a <code>process.exit</code> call inside a timer that fires after a random amount of time:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In server.js</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  process.exit(<span class="number">1</span>) <span class="comment">// death by random timeout</span></span><br><span class="line">&#125;, <span class="built_in">Math</span>.random() * <span class="number">10000</span>)</span><br></pre></td></tr></table></figure>

<p>When a worker process exits like this, the master process will be notified using the <code>exit</code> event on the <code>cluster</code> model object. We can register a handler for that event and just fork a new worker process when any worker process exits.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Right after the fork loop within the isMaster=true block</span></span><br><span class="line"></span><br><span class="line">cluster.on(<span class="string">&#x27;exit&#x27;</span>, <span class="function">(<span class="params">worker, code, signal</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (code !== <span class="number">0</span> &amp;&amp; !worker.exitedAfterDisconnect) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Worker <span class="subst">$&#123;worker.id&#125;</span> crashed. Starting a new worker...`</span>)</span><br><span class="line">    cluster.fork()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>It’s good to add the if condition above to make sure the worker process actually crashed and was not manually disconnected or killed by the master process itself.</p>
<p>If the main process is going to kill the worker, it can use the <code>disconnect</code> methods on the worker and in that case, the <code>exitedAfterDisconnect</code> flag will be set to true. The if statement above will guard to not fork a new worker for that case.</p>
<p>If we run the cluster with the handler above(and the random crash in server.js), after a random number of seconds, workers will start to crash and the master process will immediately fork new workers to increase the availability of the system.</p>
<p>You can actually measure the availability using the same <code>ab</code> command and see how many requests the server will not be able to handle overall.</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*B72o6QhsyiNnEQU5Wx20RQ.png"></p>
<h3 id="Zero-downtime-Restarts"><a href="#Zero-downtime-Restarts" class="headerlink" title="Zero-downtime Restarts"></a>Zero-downtime Restarts</h3><p>We have multiple instances running, so instead of restarting them together, we can simply restart them one at a time to allow other workers to continue to serve requests while one worker is being restarted.</p>
<p>Implementing this with the cluster module is easy. Since we don’t want to restart the master process once it’s up, we need a way to send this master process a command to instruct it to start restarting its workers. This is easy on Linux system because we can simply listen to a process signal like <code>SIGUSR2</code>, which we can trigger by using the <code>kill</code> command on the process id and passing that signal:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In Node</span></span><br><span class="line">process.on(<span class="string">&#x27;SIGUSR2&#x27;</span>, <span class="function">() =&gt;</span> &#123; ... &#125;)</span><br><span class="line"><span class="comment">// To trigger that</span></span><br><span class="line">$ kill -SIGUSR2 PID</span><br></pre></td></tr></table></figure>

<p>This way, the master process will not be killed and we have a way to instruct it to start doing something.</p>
<p><strong><code>SIGUSR2</code> is a proper signal to use here because this will be a user command. If you’re wondering why not <code>SIGUSR1</code>, it’s because Node uses that for its debugger and you want to avoid any conflicts.</strong>.</p>
<p>When the master process receives the <code>SIGUSR2</code> signal, that means it’s time for it to restart its workers, but we want to do that one worker at a time. This simply means the master process should only restart the next worker when it’s done restarting the current one.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restartWorker</span> = (<span class="params">workerIndex</span>) =&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> worker = workers[workerIndex]</span><br><span class="line">  <span class="keyword">if</span> (!worker) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  worker.on(<span class="string">&#x27;exit&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!worker.exitedAfterDisconnect) <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Exited process <span class="subst">$&#123;worker.process.pid&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">    cluster.fork().on(<span class="string">&#x27;listening&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      restartWorker(workerIndex + <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  worker.disconnect()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restartWorker(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>Inside the <code>restartWorker</code> function, we got a reference to the worker to be restarted and since we will be calling this function recursively to form a sequence, we need a stop condition. When we no longer have a worker to restart, we can just return.</p>
<p>We then basically want to disconnect this worker (using <code>worker.disconnect</code>), but before restarting the next worker, we need to fork a new worker to replace this current one that we’re disconnecting.</p>
<p>We can use the <code>exit</code> event on the worker itself to fork a new worker when the current one exists, but we have to make sure that the exit action was actually triggered after a normal disconnect call. We can use the <code>exitedAfterDisconnect</code> flag. If this flag is not true, the exit was caused by something else other than our disconnect call and in that case, we should just return and do nothing. But if the flag is set to true, we can go ahead and fork a new worker to replace the one that we’re disconnecting.</p>
<p>When this new forked worker is ready, we can restart the next one.</p>
<p>However, remember that the fork process is not synchronous, so we can’t just restart the next worker after the fork call. Instead, we can monitor the <code>listening</code> event on the newly forked worker, which tells us that this worker is connected and ready. When we get this event, we can safely restart the next worker in sequence.</p>
<p>That’s all we need for a zero-downtime restart.</p>
<p>Process monitors like PM2, make all the tasks we went through so far extremely easy and give a log more features to monitor the health of a Node’s application.</p>
<h3 id="Shared-State-and-Sticky-Load-Balancing"><a href="#Shared-State-and-Sticky-Load-Balancing" class="headerlink" title="Shared State and Sticky Load Balancing"></a>Shared State and Sticky Load Balancing</h3><p>When we load balance a Node application, we lost some features that are only suitable for a single process. This problem is somehow similar to what’s known in other languages as thread safety, which is about sharing data between threads. In our case, it’s sharing data between worker processes.</p>
<p>For example, with a cluster setup, we can no longer cache things in memory because every worker process will have its own memory space, If we cache something in one worker’s memory, other workers will not have access to it.</p>
<p>If we need to cache things with a cluster setup, we have to use a separate entity and read/write to that entity’s API from all workers. This entity can be a database server or if you want to use in-memory cache you can use a server like Redis or create a dedicated Node process with a read/write API for all other workers to communicate with.</p>
<p><img src="https://cdn-images-1.medium.com/max/1000/1*dIR_CAkmtPFgtaGTOKBFkA.png"></p>
<p>Don’t look at this as a disadvantage, because using a separate entity for your application caching is part of <em>decomposing</em> your app for scalability. You should probably be doing that even if you’re running on a single core machine.</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Chen Yu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://ezcook.de/2017/08/22/Scaling-Node-js-App/">https://ezcook.de/2017/08/22/Scaling-Node-js-App/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Node-js/">Node.js</a></div><div class="post_share"><div class="social-share" data-image="/img/default_cover_1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2017/08/22/Node-Child-Process/"><img class="prev-cover" src="/img/default_cover_1.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Node Child Process</div></div></a></div><div class="next-post pull-right"><a href="/2017/08/22/Mock-Data-for-Node-js/"><img class="next-cover" src="/img/default_cover_1.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Mock Data for Node.js</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/10/10/Basic-components-in-nest-js/" title="Basic Components in nest.js"><img class="relatedPosts_cover" src="/gallery/thumbnails/nestjs_components.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-10-10</div><div class="relatedPosts_title">Basic Components in nest.js</div></div></a></div><div class="relatedPosts_item"><a href="/2017/08/07/Build-GraphQL-Server-with-Express/" title="Build GraphQL Server With Express"><img class="relatedPosts_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2017-08-07</div><div class="relatedPosts_title">Build GraphQL Server With Express</div></div></a></div><div class="relatedPosts_item"><a href="/2017/08/10/Build-GraphQL-Server-with-Koa/" title="Build GraphQL Server With Koa"><img class="relatedPosts_cover" src="img/default_cover_2.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2017-08-10</div><div class="relatedPosts_title">Build GraphQL Server With Koa</div></div></a></div><div class="relatedPosts_item"><a href="/2017/09/06/Build-Node-CLI/" title="Build Node CLI"><img class="relatedPosts_cover" src="img/default_cover_0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2017-09-06</div><div class="relatedPosts_title">Build Node CLI</div></div></a></div><div class="relatedPosts_item"><a href="/2017/06/30/Example-of-node-influx/" title="Example of Node-Influx"><img class="relatedPosts_cover" src="img/default_cover_1.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2017-06-30</div><div class="relatedPosts_title">Example of Node-Influx</div></div></a></div><div class="relatedPosts_item"><a href="/2017/10/26/Fastify-Plugin-Guide/" title="Fastify Plugin Guide"><img class="relatedPosts_cover" src="img/default_cover_2.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-26</div><div class="relatedPosts_title">Fastify Plugin Guide</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2015 - 2021 By Chen Yu</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><script type="text/javascript" id="maid-script" mermaidoptioins="{&quot;theme&quot;:&quot;dark&quot;,&quot;background&quot;:&quot;#fff!important&quot;}" src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="Increase Font Size"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="Decrease Font Size"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="/js/search/algolia.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js', function () {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      [object Object] && mermaid.init()
    })
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://ezcook.de/2017/08/22/Scaling-Node-js-App/'
    this.page.identifier = '2017/08/22/Scaling-Node-js-App/'
    this.page.title = 'Scaling Node.js App'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://ezcook-de.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Disqus' === 'Disqus' || !false) {
  if (false) loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script><script>if (window.DISQUSWIDGETS === undefined) {
  var d = document, s = d.createElement('script');
  s.src = 'https://ezcook-de.disqus.com/count.js';
  s.id = 'dsq-count-scr';
  (d.head || d.body).appendChild(s);
} else {
  DISQUSWIDGETS.getCount({reset: true});
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  'meta[name=description]',
  '#config_change',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

const pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
})

document.addEventListener('pjax:complete', function () {
  refreshFn()

  $('script[data-pjax]').each(function () {
    $(this).parent().append($(this).remove())
  })

  GLOBAL_CONFIG.islazyload && lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', 'UA-136207372-1', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

})

document.addEventListener('pjax:send', function () {
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  $(window).off('scroll')

  //reset readmode
  $('body').hasClass('read-mode') && $('body').removeClass('read-mode')

  //reset font-size
  $('body').css('font-size') !== originFontSize && $('body').css('font-size', parseFloat(originFontSize))
})</script></div></body></html>
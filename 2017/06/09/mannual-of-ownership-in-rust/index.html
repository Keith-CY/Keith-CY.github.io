<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Mannual of Ownership in Rust  | EzCook</title><meta name="description" content="Ownership is Rust’s most unique feature, and it enables Rust to make memory safety guarantees without needing a garbage collector. Therefore, it’s important to understand how ownership works in Rust."><meta name="keywords" content="Rust"><meta name="author" content="Chen Yu"><meta name="copyright" content="Chen Yu"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="https://ezcook.de/2017/06/09/mannual-of-ownership-in-rust/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin="crossorigin"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Mannual of Ownership in Rust "><meta property="og:url" content="https://ezcook.de/2017/06/09/mannual-of-ownership-in-rust/"><meta property="og:site_name" content="EzCook"><meta property="og:description" content="Ownership is Rust’s most unique feature, and it enables Rust to make memory safety guarantees without needing a garbage collector. Therefore, it’s important to understand how ownership works in Rust."><meta property="og:image" content="https://ezcook.de/img/default_cover_1.jpg"><meta property="article:published_time" content="2017-06-09T03:09:21.000Z"><meta property="article:modified_time" content="2020-08-30T12:41:21.364Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-136207372-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-136207372-1');
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: {"appId":"KU7XP6WJWL","apiKey":"6806ddc27f224d4ebc2fe49dc770371c","indexName":"Blog","hits":{"per_page":6},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: false,
  copyright: {"limitCount":50,"languages":{"author":"Author: Chen Yu","link":"Link: ","source":"Source: EzCook","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-08-30 20:41:21'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.1.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/yudan.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">311</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">76</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-address-card"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/portfolio/"><i class="fa-fw fas fa-code"></i><span> Portfolio</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#What-is-Ownership"><span class="toc-number">1.</span> <span class="toc-text">What is Ownership</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ownership-Rules"><span class="toc-number">2.</span> <span class="toc-text">Ownership Rules</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Variable-Scope"><span class="toc-number">3.</span> <span class="toc-text">Variable Scope</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#The-String-Type"><span class="toc-number">4.</span> <span class="toc-text">The String Type</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Memory-and-Allocation"><span class="toc-number">5.</span> <span class="toc-text">Memory and Allocation</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ways-Variables-and-Data-Interact-Move"><span class="toc-number">6.</span> <span class="toc-text">Ways Variables and Data Interact: Move</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ways-Variables-and-Data-Interact-Clone"><span class="toc-number">7.</span> <span class="toc-text">Ways Variables and Data Interact: Clone</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Stack-Only-Data-Copy"><span class="toc-number">8.</span> <span class="toc-text">Stack-Only Data: Copy</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ownership-and-Functions"><span class="toc-number">9.</span> <span class="toc-text">Ownership and Functions</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Return-Values-and-Scope"><span class="toc-number">10.</span> <span class="toc-text">Return Values and Scope</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference-and-Borrowing"><span class="toc-number">10.1.</span> <span class="toc-text">Reference and Borrowing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mutable-References"><span class="toc-number">10.2.</span> <span class="toc-text">Mutable References</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dangling-References"><span class="toc-number">10.3.</span> <span class="toc-text">Dangling References</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Rules-of-References"><span class="toc-number">10.4.</span> <span class="toc-text">The Rules of References</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Slices"><span class="toc-number">10.5.</span> <span class="toc-text">Slices</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-Slice"><span class="toc-number">10.6.</span> <span class="toc-text">String Slice</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-Literals-Are-Slices"><span class="toc-number">10.7.</span> <span class="toc-text">String Literals Are Slices</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-Slices-as-Parameters"><span class="toc-number">10.8.</span> <span class="toc-text">String Slices as Parameters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Other-Slices"><span class="toc-number">10.9.</span> <span class="toc-text">Other Slices</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(/img/default_cover_1.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">EzCook</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-address-card"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/portfolio/"><i class="fa-fw fas fa-code"></i><span> Portfolio</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Mannual of Ownership in Rust </div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2017-06-09T03:09:21.000Z" title="Created 2017-06-09 11:09:21">2017-06-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2020-08-30T12:41:21.364Z" title="Updated 2020-08-30 20:41:21">2020-08-30</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">Comments:</span><span class="disqus-comment-count comment-count"><a href="https://ezcook.de/2017/06/09/mannual-of-ownership-in-rust/#disqus_thread"></a></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>Ownership is Rust’s most unique feature, and it enables Rust to make memory safety guarantees without needing a garbage collector. Therefore, it’s important to understand how ownership works in Rust. In this chapter we’ll talk about ownership as well as several related features: borrowing, slices, and how Rust lays data out in memory.</p>
<h1 id="What-is-Ownership"><a href="#What-is-Ownership" class="headerlink" title="What is Ownership"></a>What is Ownership</h1><p>Rust’s central feature is <em>ownership</em>, although the feature is staightforward to explain, it has deep implications of the rest of the language.</p>
<p>All programs have to manage the way they use a computer’s memory while running. Some languages ahve garbage collecion that constantly looks for no longer used memory as the program runs. In other languages, the programmer must explicitly allocate and free the memory. Rust uses a third approach: <strong>memory is managed through a system of ownership with a set of rules that the compiler checks at compile time.</strong> No run-time costs are iccured for any of the ownership features.</p>
<p>Because ownership is a new concept for many programmers, it does take some time to get used to. The good news is that the more experienced you become with Rust and the rules of the ownership system, the more you’ll be able to naturally develop code that is safe and efficient.</p>
<h1 id="Ownership-Rules"><a href="#Ownership-Rules" class="headerlink" title="Ownership Rules"></a>Ownership Rules</h1><p>First, let’s take a look at the ownership rules.</p>
<blockquote>
<ol>
<li>Each Value in Rust has a variable that’s called its <em>owner</em>.</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>There can only be one owner at a time.</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>When the owner goes out of scope, the value will be dropped.</li>
</ol>
</blockquote>
<h1 id="Variable-Scope"><a href="#Variable-Scope" class="headerlink" title="Variable Scope"></a>Variable Scope</h1><p>A scope is the range within a program for which an item is valid.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span> </span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The variable <code>s</code> refers to a string literal, where the value of the string is hardcoded into the text of our program. The variable is valid from the point at which it’s declared until the end of the current <em>scope</em>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;                       <span class="comment">// s is not valid here</span></span><br><span class="line">  <span class="keyword">let</span> s = <span class="string">&quot;hello&quot;</span>;      <span class="comment">// s is valid here</span></span><br><span class="line">&#125;                       <span class="comment">// the scope is over, and s is no longer valid.</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>When <code>s</code> comes <em>into scope</em> it is valid</p>
</li>
<li><p>It remains so until it goes <em>out of scope</em></p>
</li>
</ul>
<p>At this point, the relationship between scopes and the valid variables are valid is similar to other programming languages. Now we’ll build on top of this understanding by introducing the <code>String</code> type.</p>
<h1 id="The-String-Type"><a href="#The-String-Type" class="headerlink" title="The String Type"></a>The String Type</h1><p>To illustrate the rules of ownership, we need a data type that is complex.</p>
<p>We’ll use <code>String</code> as the example here and concentrate on the parts of <code>String</code> that relate to ownership. These aspects also apply to other complex data types provided by the standard library and that you create.</p>
<p>We’ve already seen string literals, where a string value is hardcoded into our program. String literals are conveient, but they aren’t always suitable for every situation in which you want to use text. One reason is that they’re immutable. Another is that not every string value can be known when we write our code. For these situations, Rust has a second string type, <code>String</code>. This type is allocated on the heap and as such is able to store an amount of text that is unknown to us at compile time. You can create a <code>String</code> from a string literal using the <code>from</code> function, like so:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>The double colon(<code>::</code>) is an operator that allows us to namespace this particular <code>from</code> function under the <code>String</code> type rather than using some sort of name like <code>string_from</code>.</p>
<p>This kind of string <em>can</em> be mutated:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="symbol">&#x27;Hello</span>&#x27;)</span><br><span class="line">s.push_str(<span class="string">&quot;, world!&quot;</span>)</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br></pre></td></tr></table></figure>

<p>So why can <code>String</code> be mutated but literals cannot.</p>
<h1 id="Memory-and-Allocation"><a href="#Memory-and-Allocation" class="headerlink" title="Memory and Allocation"></a>Memory and Allocation</h1><p>In the case of a string literal, <em>we know the contents at compile</em> so the text is hardcoded directly in to the final executable, making string literals fast and efficient. But these properties only come from its immutability. Unfortunately, <em>we can’t put a blob of memory into the binary for each piece of text whose size is unknown at compile time</em> and whose size might change while running the program.</p>
<p>With the <code>String</code> type, in order to support a mutable, growable piece of text, we need to allocate an amount of memory on the heap, unknown at compile time, to hold the contents. This means:</p>
<ul>
<li><p>The memory must be requested from the operating system at runtime.</p>
</li>
<li><p>We need a way of returning this memory to the operating system when we’re done with our <code>String</code></p>
</li>
</ul>
<p>That first part is done by us: when we call <code>String::from</code>, its implementation requests the memory if needs. This is pretty much universal in programming languages.</p>
<p>However, the second part is different. In languages with a <code>garbage collector(GC)</code>, the GC keeps track and cleans up memory that isn’t being used anymore, and we, as the programmer, don’t need to think about it. Without a GC, it’s the programmer’s responsibility to identify when memory is no longer being used and call code to explicitly return it, just as we did to request it. Doing this correctly has historically been a difficult programming problem. If we forget, we’ll waste memory. If we do it too early, we’ll have an invalid vairable. If we do it twice, that’s a bug too. We need to pair exactly one <code>allocate</code> with exact one <code>free</code></p>
<p>Rust takes a different path: the memory is automatically returned once the variable that owns it goes out of scope.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;Helloe&quot;</span>); <span class="comment">// s is valid from this point</span></span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// the scope is over</span></span><br></pre></td></tr></table></figure>

<p>These is a natural point at which we can return the memory our <code>String</code> needs to operating system: when <code>s</code> goes out of scope. When a variables goes out of scope, Rust calls a special function for us. This function is called <code>drop</code>, and it’s where the author of <code>String</code> can put the code to return the memory. Rust calls <code>drop</code> automatically at the closing <code>&#125;</code>.</p>
<blockquote>
<p>Note: In C++, this pattern of deallocating resources at the end of an item’s lifetime is sometimes called <em>Resource Acquisition Is Initialization(RAII)</em>. The <code>drop</code> function in Rust will be familiar to you if you’ve used RAII patterns.</p>
</blockquote>
<p>This patterns has profound impact on the way Rust code is written. It may seem simple right now, but the behavior of code can be unexpected in more complicated situations when we want to have multiple variables use the data we’ve allocated ont the heap.</p>
<h1 id="Ways-Variables-and-Data-Interact-Move"><a href="#Ways-Variables-and-Data-Interact-Move" class="headerlink" title="Ways Variables and Data Interact: Move"></a>Ways Variables and Data Interact: Move</h1><p>Multiple variables can interact with the same data in different ways in Rust. Let’s look at an example using an integer.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br></pre></td></tr></table></figure>

<p>Here we got two independent variables <code>x</code> and <code>y</code>, this is because integers are simple values with a known, fixed size, and two <code>5</code> are pushed onto the stack.</p>
<p>Now let’s look at the <code>String</code> version.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1;</span><br></pre></td></tr></table></figure>

<p>This looks very similar to the previous code, so we might assume that the way it works would be the same: that is, the second line would make a copy of the value in <code>s1</code> and bind it to <code>s2</code>. But this isn’t quite what happens.</p>
<p>To explain this more thoroughly, let’s look at what <code>String</code> looks like under the covers in the Figure.</p>
<p><img src="https://doc.rust-lang.org/book/second-edition/img/trpl04-01.svg"></p>
<p>A <code>String</code> is made up of three parts, shown on the left: a pointer to the memory that holds the contents of the string, a length, and a capacity. This group of data is stored on the stack. On the right is the memory on the heap that holds the contents.</p>
<p>The length is how much memory, in bytes, the contents of the <code>String</code> is currently using. The capacity is the total amount of memory, in bytes, that the <code>String</code> has received from the operating system. The difference between length and capacity matters, but not in this context, so far now, it’s fine to ignore the capacity.</p>
<p>When we assign <code>s1</code> to <code>s2</code>, the <code>String</code> data is copied, meaning we copy the pointer, the length and the capacity that are on the stack. We do not copy the data on the heap that the pointer refers to. In other words, the data representation in memory looks like the figure following.</p>
<p><img src="https://doc.rust-lang.org/book/second-edition/img/trpl04-02.svg"></p>
<p>Eariler, we said that when a variable goes out of scope, Rust automatically calls the <code>drop</code> function and cleans up the heap memory for the variable. But the fact is that both data pointers pointing to the same location. This is a problem: when <code>s2</code> and <code>s1</code> go out of scope, they will both try to free the same memory. This is known as a <em>double free</em> error. Freeing memory twice can lead to memory corruption, which can potentially lead to security vulnerabilities.</p>
<p>To ensure memory safety, there’s one more detail to what happens in this situation in Rust. Instead of trying to copy the allocated memory, Rust considers <code>s1</code> to no longer be valid and therefore, Rust doesn’t need to free anything when <code>s1</code> goes out of scope. Check out what happens when you try to use <code>s1</code> after <code>s2</code> is created.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s1);</span><br></pre></td></tr></table></figure>

<p>You’ll get an error like this because Rust prevents you from using the invalidated reference:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: use of moved value: `s1`</span><br><span class="line"> --&gt; src/main.rs:4:27</span><br><span class="line">  |</span><br><span class="line">3 |  <span class="built_in">let</span> s2 = s1;</span><br><span class="line">  |     -- value moved here</span><br><span class="line">4 |  println!(<span class="string">&quot;&#123;&#125;&quot;</span>, s1);</span><br><span class="line">  |                 ^^ value used here after move</span><br><span class="line">  |</span><br><span class="line">  = note: move occurs because `s1` has <span class="built_in">type</span> `std::string::String`,</span><br><span class="line"><span class="built_in">which</span> does not implement the `Copy` trait</span><br></pre></td></tr></table></figure>

<p>This action in Rust, similar to <code>shallow copy</code>, it copy pointer, length and capacity in stack, but Rust also invalidates the first variable.</p>
<p>We call it <code>move</code>.</p>
<p><img src="https://doc.rust-lang.org/book/second-edition/img/trpl04-04.svg"></p>
<p><code>s1</code> has been invalidated.</p>
<p>That solves our problem, with only <code>s2</code> valid, when it goes out of scope, it alone will freee the memory, and we’re done.</p>
<p>In addition, there’s a design choice that’s implied by this: Rust will never automatically create ‘deep’ copies of your data. Therefore, any <em>automatic</em> copying can be assumed to be inexpensive in terms of runtime performance.</p>
<h1 id="Ways-Variables-and-Data-Interact-Clone"><a href="#Ways-Variables-and-Data-Interact-Clone" class="headerlink" title="Ways Variables and Data Interact: Clone"></a>Ways Variables and Data Interact: Clone</h1><p>If we do want to deeply copy the heap data of the <code>String</code>, not just the stack data, we can use a common method called <code>clone</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1.clone();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;</span>, s1, s2);</span><br></pre></td></tr></table></figure>

<p>This works just fine, the heap data does get copied.</p>
<p>When you see a call to <code>clone</code>, you know that some arbitrary code is being executed and that code may be expensive. It’s a visual indicator that something different is going on.</p>
<h1 id="Stack-Only-Data-Copy"><a href="#Stack-Only-Data-Copy" class="headerlink" title="Stack-Only Data: Copy"></a>Stack-Only Data: Copy</h1><p>There’s another wrinkle we haven’t talked about yet. This code using integers.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;, y = &#123;&#125;&quot;</span>, x, y);</span><br></pre></td></tr></table></figure>

<p>This code runs correctly because those types like integers that have a <strong>known size</strong> at compile time are stored entirely on the stack, so copied of the actual values are quick to make. That means there’s no reason we would want to prevent <code>x</code> from being valid after we created the variable <code>y</code>. In other words, there’s no difference between deep and shallow copying here, so calling <code>clone</code> wouldn’t do anything differently from the usual shallow copying and we can leave it out.</p>
<p>Rust has a special annotation called the <code>Copy</code> trait that we can place on types like integers that are stored on stack.</p>
<p>If a type has the <code>Copy</code> trait, an older variable is still usable after the assignment. Rust won’t let us annotate a type with the <code>Copy</code> trait if the type, or any of its parts, has implemented the <code>Drop</code> trait. If the type needs something special to happen when the value goes out of scope and we add the <code>Copy</code> annotation to that type, we’ll get a compile time error.</p>
<p>As a general rule, any group of simple scalar values can be <code>Copy</code>, and nothing that requires allocation or is some form of resource is <code>Copy</code>. Here are some of the types that are <code>Copy</code>:</p>
<ul>
<li><p>All the integer types</p>
</li>
<li><p>The boolean type</p>
</li>
<li><p>All the floating point types</p>
</li>
<li><p>Tuples, but only if they contain types a also <code>Copy</code>.</p>
</li>
</ul>
<h1 id="Ownership-and-Functions"><a href="#Ownership-and-Functions" class="headerlink" title="Ownership and Functions"></a>Ownership and Functions</h1><p><strong>The semantics for passing a value to a function are similar to assigning a value to a variable.</strong> Passing a variable to a function <strong>will move or copy</strong>, just like assignment.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span> </span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// s comes into scope</span></span><br><span class="line"></span><br><span class="line">  take_ownership(s); <span class="comment">// s&#x27;s value moves into the function</span></span><br><span class="line">                     <span class="comment">// s is no longer valid here</span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">5</span>;         <span class="comment">// x comes into scope</span></span><br><span class="line"></span><br><span class="line">  make_copy(x);      <span class="comment">// x would move into the function, but i32 is Copy, so it&#x27;s okay to still use x afterward.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">take_ownership</span> </span>(some_string: <span class="built_in">String</span>) &#123; <span class="comment">// some_string comes into scope</span></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_string);</span><br><span class="line">&#125; <span class="comment">// here, some_string goes out of scope and `drop` is called. The backing memory is freed.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">make_copy</span> </span>(some_integer: <span class="built_in">i32</span>) &#123; <span class="comment">//  some_integer comes into scope</span></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_integer);</span><br><span class="line">&#125; <span class="comment">// Here some_integer goes out of scope.</span></span><br></pre></td></tr></table></figure>

<p>If we tried to use <code>s</code> after the call to <code>take_ownership</code>, Rust would throw a compile time error. These static checks protect us from mistakes.</p>
<h1 id="Return-Values-and-Scope"><a href="#Return-Values-and-Scope" class="headerlink" title="Return Values and Scope"></a>Return Values and Scope</h1><p>Returning values can also transfer ownership.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span> </span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> s1 = give_ownership(); <span class="comment">// give_ownership moves its return value into s1</span></span><br><span class="line">  <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// s2 comes into scope</span></span><br><span class="line">  <span class="keyword">let</span> s2 = take_and_give_back(s2); <span class="comment">// s2 is moved into take_and_give_back, which aslo move its returned value into s2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">give_ownership</span> </span>() -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> some_string = <span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// some_string comes into scope</span></span><br><span class="line">  some_string      <span class="comment">// some_string is returned and moves out to the calling function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">take_and_give_back</span></span>(a_string: <span class="built_in">String</span>) -&gt; &#123; <span class="comment">// a_string comes into scope</span></span><br><span class="line">  a_string <span class="comment">// a_string is returned and moves out to the calling function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It’s possible to return mutiple values using a tuple.</p>
<h2 id="Reference-and-Borrowing"><a href="#Reference-and-Borrowing" class="headerlink" title="Reference and Borrowing"></a>Reference and Borrowing</h2><p>Here is how you would define and use a <code>calculate_length</code> function that has a <em>reference</em> to an object as a parameter instead of taking ownership of the value.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span> </span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> len = calculate_length(&amp;s1);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: &amp;<span class="built_in">String</span>) - <span class="built_in">usize</span> &#123;</span><br><span class="line">  s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>First notice that all the tuple code in the variable declaration and the function return value is gone. Second, note that we pass <code>&amp;s1</code> into <code>calculate_length</code>, and in its definition, we take <code>&amp;String</code> rather than <code>String</code>.</p>
<p>These ampersands(&amp;) are <em>reference</em>, and they allow you to refer to some value without taking ownership of it.</p>
<p><img src="https://doc.rust-lang.org/book/second-edition/img/trpl04-05.svg"></p>
<p>In this figure, <code>&amp;String s</code> pointing to <code>String s1</code></p>
<p>Let’s take a closer look at the function call here:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> len = calculate_length(&amp;s1)</span><br></pre></td></tr></table></figure>

<p>The <code>&amp;s1</code> syntax lets us create a reference that <em>refer</em> to the value of <code>s1</code>, but does not own it.</p>
<p><strong>Because it does not own it, the value it points to will not be dropped when the reference goes out of scope.</strong></p>
<p>Likewise, the signature of the function uses <code>&amp;</code> to indicate that the type of the paramter <code>s</code> is a reference.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123; <span class="comment">// s is a reference to a String</span></span><br><span class="line">  s.len()</span><br><span class="line">&#125; <span class="comment">// Here, s goes out of the scope. But because it does not have ownership of what it refers to, no drop happens.</span></span><br></pre></td></tr></table></figure>

<p>The scope in which the variable <code>s</code> is valid is the same as any function parameter’s scope, but we don’t drop what the reference points to when it goes out of scope because we don’t have ownership.</p>
<p>Functions that have references as parameters instead of the actual values mean we won’t need to return the values in order to give back ownership, since we never had ownership.</p>
<p>We call having references as function paramters <code>borrowing</code>. As in real life, if a person owns something, you can borrow it from them, When you’re done, you have to give it back.</p>
<p>If we try to modify something we’re borrowing, it won’t work.</p>
<h2 id="Mutable-References"><a href="#Mutable-References" class="headerlink" title="Mutable References"></a>Mutable References</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span> </span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  change(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change</span></span>(some_string: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">  some_string.push_str(&#x27;, world&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>First, we had to change <code>s</code> to be <code>mut</code>. Then we had to create mutable reference with <code>&amp;mut s</code> and accept a mutable reference with <code>some_string: &amp;mut String</code>.</p>
<p>But mutable references have one big restriction: you can only mutable reference to a particular piece of data in a particular scope.</p>
<p>This restriction allows for mutation but in a very controlled fashion. It’s something that new Rustaceans struggle with, because most languages let you mutate whenever you’d like. The benefit of having this restriction is that <em>Rust can prevent data races at compile time</em>.</p>
<p>A <code>data race</code> is a particular type of race condition in which these three behaviors occur:</p>
<ul>
<li><p>Two or more pointers access the same data at the same time.</p>
</li>
<li><p>At least one of the pointers is being used to write to the data.</p>
</li>
<li><p>There’s no mechanism being used to synchrnize access to the data.</p>
</li>
</ul>
<p>Data races cause undefined behavior and can be difficult to diagnose and fix when you’re trying to track them down at runtime. Rust prevents this problem from happening because it won’t even compile code with data race.</p>
<p>As always, we can use curly brackets to create a new scope, allowing for multiple mutable references, just not <em>simultaneous</em> ones:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> r1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> s;</span><br></pre></td></tr></table></figure>

<p>A similar rule exists for combining mutable and immutable references. This code results in an error:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> r1 = &amp;s; <span class="comment">// no problem</span></span><br><span class="line"><span class="keyword">let</span> r2 = &amp;s; <span class="comment">// no problem</span></span><br><span class="line"><span class="keyword">let</span> r3 = &amp;<span class="keyword">mut</span> s; <span class="comment">//BIG PROBLEM, mutable borrow occurs</span></span><br></pre></td></tr></table></figure>

<p>We also cannot have mutable reference while we have an immutable one.</p>
<p>Users of an immutable reference don’t expect the values to suddently change out from under them.</p>
<h2 id="Dangling-References"><a href="#Dangling-References" class="headerlink" title="Dangling References"></a>Dangling References</h2><p>In languages with pointers, it’s easy to erroneously to create a <em>dangling pointer</em>, a pointer that references a location in memory that may have been given to someone else, by freeing some memory while preserving a pointer to that memory. In Rust, by contrast, the compiler guarantees the references will never be dangling references: if we have a reference to some data, the compiler will ensure that the data will not go out of scope before reference to the data does.</p>
<h2 id="The-Rules-of-References"><a href="#The-Rules-of-References" class="headerlink" title="The Rules of References"></a>The Rules of References</h2><ul>
<li><p>At any given time, you can have <code>either</code> but not both of</p>
<ul>
<li><p>One mutable reference</p>
</li>
<li><p>Any number of immutable references</p>
</li>
</ul>
</li>
<li><p>Referecences must always be valid.</p>
</li>
</ul>
<h2 id="Slices"><a href="#Slices" class="headerlink" title="Slices"></a>Slices</h2><p>Another data type that doesn’t have ownership is the <code>slice</code>. Slices let you reference a configuous sequence of elements in a collection rather tahn the whole collection.</p>
<h2 id="String-Slice"><a href="#String-Slice" class="headerlink" title="String Slice"></a>String Slice</h2><p>A <em>string slice</em> is a reference to part of a <code>String</code>, and looks like this:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hello = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> world = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br></pre></td></tr></table></figure>

<p>This is similar to taking a reference to the whole <code>String</code>, but with the extra <code>[0..5]</code> but. Rather than a reference to the entire <code>String</code>, it’s a reference to an internal position in the <code>String</code> and the number of elements that it refers to.</p>
<p>We create slices with a range of <code>[start_index..end_index]</code>, but the slice data structure acutally <strong>stores the starting position and the length of the slice</strong>.</p>
<p>So in the case of <code>let world = &amp;s[6..11];</code>, <code>world</code> would be a slice that contains a pointer to the 6th byte of <code>s</code> and a length of value of 5.</p>
<p><img src="https://doc.rust-lang.org/book/second-edition/img/trpl04-06.svg"></p>
<p>With Rust’s <code>..</code> range syntax, if you want to start at the first index(0), you can drop the value before the two periods. In other words</p>
<p>By the same token, if your slice includes the last byte of the <code>String</code>, you can drop the trailing number.</p>
<p>You can also drop both values to take a slice of the entire string.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span> </span>(s: &amp;<span class="built_in">String</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> bytes = s.as_bytes();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">    <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String-Literals-Are-Slices"><a href="#String-Literals-Are-Slices" class="headerlink" title="String Literals Are Slices"></a>String Literals Are Slices</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;Hello, World&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>The type of <code>s</code> here is <code>&amp;str</code>: it’s a slice pointing to the specific point of the binary. This is also why string literals are immutable; <code>&amp;str</code> is an immutable reference.</p>
<h2 id="String-Slices-as-Parameters"><a href="#String-Slices-as-Parameters" class="headerlink" title="String Slices as Parameters"></a>String Slices as Parameters</h2><p>Knowing that you can take slices of literals and <code>String</code>s leads us to one more improvement on <code>first_word</code>, and that’s its signature:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">first_word</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br></pre></td></tr></table></figure>

<p>If we have a string slice, we can pass that directly. If we have a <code>String</code>, we can pass a slice of the entire <code>String</code>. Defining a function to take a string slcie instead of a reference to a String makes our API more general and useful without losing any functionality.</p>
<h2 id="Other-Slices"><a href="#Other-Slices" class="headerlink" title="Other Slices"></a>Other Slices</h2><p>String slices, as you might imagine, are specific to strings. But there’s a more general slice type, too.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> slice = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>This slice has the type <code>&amp;[i32]</code>. It works the same way as string slices do, by storing a reference to the first element and the length.</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Chen Yu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://ezcook.de/2017/06/09/mannual-of-ownership-in-rust/">https://ezcook.de/2017/06/09/mannual-of-ownership-in-rust/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Rust/">Rust</a></div><div class="post_share"><div class="social-share" data-image="/img/default_cover_1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2017/06/12/Type-Compatibility-in-TypeScript/"><img class="prev-cover" src="/img/default_cover_2.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Type Compatibility in TypeScript</div></div></a></div><div class="next-post pull-right"><a href="/2017/06/06/Basic-Info-of-Web-Worker/"><img class="next-cover" src="/img/default_cover_0.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Basic Info of Web Worker</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2017/11/06/Rocket-of-Rust/" title="Rocket of Rust"><img class="relatedPosts_cover" src="img/default_cover_1.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2017-11-06</div><div class="relatedPosts_title">Rocket of Rust</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2015 - 2020 By Chen Yu</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><script type="text/javascript" id="maid-script" mermaidoptioins="{&quot;theme&quot;:&quot;dark&quot;,&quot;background&quot;:&quot;#fff!important&quot;}" src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="Increase Font Size"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="Decrease Font Size"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="/js/search/algolia.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js', function () {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      [object Object] && mermaid.init()
    })
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://ezcook.de/2017/06/09/mannual-of-ownership-in-rust/'
    this.page.identifier = '2017/06/09/mannual-of-ownership-in-rust/'
    this.page.title = 'Mannual of Ownership in Rust '
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://ezcook-de.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Disqus' === 'Disqus' || !false) {
  if (false) loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script><script>if (window.DISQUSWIDGETS === undefined) {
  var d = document, s = d.createElement('script');
  s.src = 'https://ezcook-de.disqus.com/count.js';
  s.id = 'dsq-count-scr';
  (d.head || d.body).appendChild(s);
} else {
  DISQUSWIDGETS.getCount({reset: true});
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  'meta[name=description]',
  '#config_change',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

const pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
})

document.addEventListener('pjax:complete', function () {
  refreshFn()

  $('script[data-pjax]').each(function () {
    $(this).parent().append($(this).remove())
  })

  GLOBAL_CONFIG.islazyload && lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', 'UA-136207372-1', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

})

document.addEventListener('pjax:send', function () {
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  $(window).off('scroll')

  //reset readmode
  $('body').hasClass('read-mode') && $('body').removeClass('read-mode')

  //reset font-size
  $('body').css('font-size') !== originFontSize && $('body').css('font-size', parseFloat(originFontSize))
})</script></div></body></html>